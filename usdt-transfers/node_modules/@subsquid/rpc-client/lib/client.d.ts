import { Logger } from '@subsquid/logger';
import { RpcConnectionError } from './errors';
import { RpcCall, RpcErrorInfo, RpcNotification, RpcRequest } from './interfaces';
import { Subscription, SubscriptionHandle } from './subscriptions';
export interface RpcClientOptions {
    url: string;
    maxBatchCallSize?: number;
    capacity?: number;
    requestTimeout?: number;
    rateLimit?: number;
    retryAttempts?: number;
    retrySchedule?: number[];
    log?: Logger | null;
}
export interface CallOptions<R = any> {
    priority?: number;
    retryAttempts?: number;
    timeout?: number;
    /**
     * Result validator/transformer
     *
     * This option is mainly a way to utilize built-in retry machinery by throwing {@link RetryError}.
     * Otherwise, `client.call(...).then(validateResult)` is a better option.
     */
    validateResult?: ResultValidator<R>;
    validateError?: ErrorValidator<R>;
}
type ResultValidator<R = any> = (result: any, req: RpcRequest) => R;
type ErrorValidator<R = any> = (info: RpcErrorInfo, req: RpcRequest) => R;
export declare class RpcClient {
    private counter;
    private queue;
    readonly url: string;
    private con;
    private maxBatchCallSize;
    private requestTimeout;
    private retrySchedule;
    private retryAttempts;
    private capacity;
    private maxCapacity;
    private log?;
    private rate?;
    private rateLimit;
    private schedulingScheduled;
    private connectionErrorsInRow;
    private connectionErrors;
    private requestsServed;
    private notificationsReceived;
    private backoffEpoch;
    private notificationListeners;
    private resetListeners;
    private closed;
    constructor(options: RpcClientOptions);
    private createConnection;
    getConcurrency(): number;
    getMetrics(): {
        url: string;
        requestsServed: number;
        connectionErrors: number;
        notificationsReceived: number;
    };
    private onNotification;
    private safeCallback;
    addNotificationListener(cb: (msg: RpcNotification) => void): void;
    removeNotificationListener(cb: (msg: RpcNotification) => void): void;
    addResetListener(cb: (reason: Error) => void): void;
    removeResetListener(cb: (reason: Error) => void): void;
    subscribe<T>(sub: Subscription<T>): SubscriptionHandle;
    private subscriptions;
    supportsNotifications(): boolean;
    call<T = any>(method: string, params?: any[], options?: CallOptions<T>): Promise<T>;
    batchCall<T = any>(batch: RpcCall[], options?: CallOptions<T>): Promise<T[]>;
    private batchCallInternal;
    private enqueue;
    private schedule;
    private delayScheduling;
    private performScheduling;
    private send;
    private waitForConnection;
    private backoff;
    private getBackoffPause;
    private receiveResult;
    isConnectionError(err: Error): boolean;
    reset(reason?: RpcConnectionError): void;
    close(err?: Error): void;
    private assertNotClosed;
}
export {};
//# sourceMappingURL=client.d.ts.map